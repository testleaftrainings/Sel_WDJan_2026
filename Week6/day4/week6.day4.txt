Recap :

1) POM Introduction : what? why? how?
Design pattern :
                   Each webpage as a separate .java file 
                   Each functionality inside the webpage as a separate method()
2) create each object for the each page, we called the respective methods using that specific object  :  Builder 

3) Only object is created, for the 1st page other class objects were connected using return keyword   :  Singleton 

4) POM sequential Execution : return  default Constructor
   which java keyword we used to represent current class reference --> this


###########################################
POM parallel Execution : return  Parameterized Constructor


Cucumber : feature,steps,runner

Cucumber with POM:
------------------
 - Create 4 packages
     - base
        Create BaseClass with common methods
        BaseClass should extend AbstractTestNGCucumberTests
     - features
         Create feature files
     - pages/steps
        Create classes for each page and each page should extend BaseClass
     - runner
        Create CucumberRunner class and , mention glue="pages"
        The runner class should extend BaseClass

###########################################
Thread :

testng.xml -> threadcount=2
java--> Thread.sleep()
testNG attributes--> threadPoolsize



The Thread class in Java is used for creating and managing threads, which enable concurrent execution of tasks. 

Why is one thread executing fully before the other?

1)Thread Scheduling is Non-Deterministic

The JVM assigns CPU time to threads based on the OS's thread scheduler.

Sometimes, the OS may allow Thread-0 to complete all its iterations before giving CPU time to Thread-1.

2)CPU Time Slice Allocation

Some OS schedulers may allocate longer time slices to a thread before switching to another.

This could cause one thread (Thread-0) to run completely before Thread-1 starts.

3)System Load and Thread Priority

If the system is lightly loaded, the OS may not interrupt the running thread until it finishes.

The Thread class uses default priority (5), which might allow one thread to complete before the other gets CPU time.


Is This Behavior Guaranteed?
      No! If you run the program multiple times, you might see different outputs where Thread-0 and Thread-1 interleave. The execution order depends on the JVM and OS.

When running TestNG tests in parallel mode, multiple test methods or classes execute concurrently using separate threads. The TestNG XML configuration defines the parallel execution mode (methods, classes, tests, or suites).


Step-by-Step Execution
1Ô∏è‚É£ TestNG starts execution and creates multiple threads (as per thread-count).
2Ô∏è‚É£ Each test method is assigned to a separate thread for parallel execution.
3Ô∏è‚É£ Threads execute methods independently, meaning TestClassA.test1 and TestClassB.test1 can run at the same time.
4Ô∏è‚É£ Once a thread completes one test method, it moves to the next available test method.
5Ô∏è‚É£ Test execution completes when all threads finish executing their assigned test methods.



###########################################

Pom-ThreadLocal:
---------------

What is ThreadLocal in Java?

ThreadLocal<T> is a Java class that provides thread-local variables. These variables are isolated per thread, meaning each thread has its own copy, preventing conflicts when multiple threads access shared data(pages).Each thread holds an implicit reference to its copy of a thread-local
 * variable as long as the thread is alive.
ThreadLocal Used to create thread local variables. Each thread will have its own 
copy of a thread local variable.





private - a variable which is accessible only within that class


//org.openqa.selenium.WebDriverException : TIMEOUT
	//org.openqa.selenium.StaleElementReferenceException : Driver value is same



   static -one instance will be shared among all the classes
      final-variable once initialized cannot be changed.


Steps: 1. private static final ThreadLocal<RemoteWebDriver> rd = new ThreadLocal<RemoteWebDriver>();

 private:
   It can be accessed only within the class
 static final:
    static+final = constant
 ThreadLocal:
   It is a class that provides thread-local variable

‚úÖ Why private members are accessed using public methods
In Java, the reason we make variables private and access them via public getter/setter methods is to follow the Object-Oriented Programming principle of Encapsulation.

üîí 1. What is Encapsulation?
Encapsulation is the concept of hiding internal object details and exposing only what's necessary to the outside world.

üéØ Goal:
Restrict direct access to the object's internal state.

Provide controlled, safe access through public methods.

üß± 2. Why Use private + public Combo?
Reason			|	Explanation
-----------------------------------------------------------------------------------------------
‚úÖ Data Protection	|	Prevents unwanted or accidental modification of internal data.
‚úÖ Controlled Access	|	You decide who can read/write and how.
‚úÖ Validation Logic	|	Setters can include validation before setting values.
‚úÖ Future Flexibility	|	You can change internal implementation without affecting external code.
‚úÖ Read-Only		|	You can expose only get or only set if needed.
   or Write-Only Access

2. Use setter and getter methods
     Sets the current thread's copy of this thread-local variable

      public void setDriver(RemoteWebDriver driver) {
	rd.set(driver);

}
 Returns the value in the current thread's copy of this thread-local variable   
public RemoteWebDriver getDriver() {
	return rd.get();
}

@BeforeMethod
public void precondition(){
  setDriver();
  then replace driver variable into getDriver()
  getDriver().manage.window.maximize();
}





For TestNG _POM : - with driver as static -> sequential execution is possible
 - To have sequential and parallel execution declare Parameterized Constructor in each pages

For Cucumber_POM: 
- Constructor should not be defined 
- With driver as static 
-> sequential execution is possible
