

Recap : Static Parameterization + Cross browser testing
 (XML) <parameter name ="uname" value ="demosalesmanager">  
 (XML) <parameter name ="pword" value ="crmsfa">  
 (XML) <parameter name ="browserName" value ="chrome">  
              ||  
@parameters({"uname","pword","browserName"}) 
                        || 
            (String uname , String pword, String url)
                              || 
                          .sendKeys(uname)
                (parameterization principle : no hardcorded value)









###################################################################################

Dynamic Parameterization
Steps to implement Dynamic Parameterization:

1)Identify the datas that are specific to the particular testcase 
ex: CreateLead - compnayname, firstname, lastname, phonenumber 
	EditLead - phonenumber,companyname
2)Create a method sendData() inside the CreateLead class
3)Annotate that method with @DataProvider
4)Inside sendData() create 2-Dimensional array with number of rows and columns
	Add all the sets of data into the array and make sure the index starts from 0
5)Return the data back to the calling method
6)Receive this data in the test method
	use dataprovider attibute
	use that arguments inside the method.
7)Finally, replace the hardcoded values
8)In xml do right click --> Run as --> TestNG Suite





Steps to achive Dynamic Parameterization

1)In TestCase class declare a method as sendData() and Use annotation as @DataProvider
2)Create obj for 2D String and pass no.of.testdatas and testdata info count (row and col size)
3)Declare values/testdatas for data[][]
4)return data variable
5)In @Test invoke the dataProvider(Attribute) and assign @DataProvider methodName
6)Add Method input argument for the testdata information (It should be a same order)
7)Remove hardcorded data and use variables

ðŸ’¼ Real Use Cases in Automation Projects

âœ… Use Case 1: Form Validation
Test a form with multiple sets of data (positive and negative).

âœ… Use Case 2: Data-Driven Testing
Pull data from Excel, CSV, JSON, or a database to test a feature with real user inputs.

âœ… Use Case 3: Boundary and Edge Case Testing
Provide edge inputs like min/max lengths, nulls, and special characters.



#############################################################################################


Read Excel:

<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>5.2.3</version>
</dependency>

<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>5.2.3</version>
</dependency>


#############################################################################################
How to read data from Excel:



steps to create excelsheet in data folder:

1.rightclick--->project--->clicknew-->folder--->foldername-->data-->finish
2.right click on the folder--->show in--->system explorer-->doubleclick on data-->rightclick-->new--->ms excelsheet.

Excel:
Login.xls= -> Microsoft excel spreadsheet
Login.xlsx -> Microsoft excel spreadsheet in xml format

XSSF-> XML SpreadSheet Format


Step1-> Set path for workbook
step2-> Get into the sheet
Step3-> Get into Row values
Step4-> Get into cell values
Step5-> Read Data from workbook and print
Step6-> close the workbook

Fun Fact : 

ðŸ”¹ getLastRowNum() â†’ int
Returns: The 0-based index of the last physical row in the sheet.

Why int?

Excel supports up to 10,48,576 rows (in .xlsx format).

Since this number is far beyond what a short (max value 32,767) can hold, the method must return int.

ðŸ”¹ getLastCellNum() â†’ short
Returns: The index of the last cell + 1 (i.e., count of the last column in the row).

Why short?

Excel supports a maximum of 16,384 columns (column XFD in .xlsx format).

16,384 fits well within the short data type range:

short in Java ranges from -32,768 to 32,767

So using short saves memory and matches Excelâ€™s constraints.


#############################################################################################

##########################################################################
Steps to do Excel Common Integration
1. Create 2- dimensional array in the ReadEXcel Class with rowCount and columnCount
2. Push stringCellValue to the Array
3. Close the workbook and return the data
4. Change main method to a normal static method -retrain the static keyword
5. Inside the testcase within the sendData() call the readExcel() from ReadExcel Class and return the data
6.  inside excel program craete one input agrs and pass variable inside workbook
7. Create setValues() inside each testcase and annotate with @BeforeTest and mention the filename here
8. Finally , run fromÂ theÂ xmlÂ file


################################################################################################

# Steps to do Excel Integration:

1. Create 2- dimensional array in the ReadExcel Class with rowCount and columnCount
String[][] testRecord = new String[rowCount][columnCount];

2. Push stringCellValue to the Array
DataProvider what index value it will be started - 0
Excel program what index value for row - 1

convert excel into DataProvider
testRecord[i-1][j]=stringCellValue;

3. Close the workbook and return the data
excel.close();
return testRecord;

4. Change main method to a normal static method -retrain the static keyword
public static String[][] extractDataFromExcel(){
}

5. Inside the testcase within the dataLibrary() call the extractDataFromExcel() from ReadExcel Class and return the testRecord
@DataProvider(name="extractData")
public String[][] dataLibrary() throws IOException {
    
return ReadExcel.readExcel();

6.inside excel program craete one input agrs and pass variable inside workbook
 (./data/"+fileName+".xlsx)
 
7. inside the BaseClass or PSM  and declare a fileName globally
 
public String fileName; ------------ > Global declaration
@DataProvider(name="extractData")
public String[][] dataLibrary() throws IOException {
return ReadExcel.extractDataFromExcel(fileName); 
}
8. Create sendLeadData() inside each testcase and annotate with @BeforeTest and mention the filename here
@BeforeTest
public void sendLeadData() {
fileName="ClassName";
} 
9. Finally , run fromÂ theÂ xmlÂ file

##########################################################




Gobal variables : driver , fileName
 @BeforeTest-initializing the fileName here
      @DataProvider
         @parameters
           @BeforeMethod- required data for the testcases are collected here -PSM
                    initializing the driver here
                @Test
            @AfterMethod



##########################################################





https://cucumber.github.io/cucumber-eclipse/update-site - plugin
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-testng</artifactId>
    <version>7.15.0</version>
</dependency>

<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-java</artifactId>
    <version>7.15.0</version>
    </dependency>

###############################
