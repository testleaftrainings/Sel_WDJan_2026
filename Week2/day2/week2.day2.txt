----------------------------------------
Steps to inspect the web element:-

1) right click --> click inspect; you can view the DOM
2) fn+ F12 or F12 --> it will open the DOM
3) Shorcut--> shf+ctrl+i --> it will open the DOM
4) Shorcut--> shf+ctrl+c --> it will open the DOM along scope/spy tool

----------------------------------------
----------------------------------------
Locator statergy:

1)id locator:

The id locator is the most preferred because of its uniqueness, performance, and simplicity.
It uses the browser's native methods (e.g., document.getElementById()), which are highly efficient.
Modern browsers are designed to optimize the performance of common operations like By.Id(). 
By.Id() directly fetches the element(No Need for Traversal) because of constant-time lookups.

2)name locator:
The name attribute is commonly used in form elements (e.g., <input>, <select>, <textarea>) to identify form fields when the form is submitted.
It is also used to group related elements, such as radio buttons or checkboxes, where multiple elements share the same name to indicate they belong to the same group.
Why Duplicates?:

The name attribute is designed to group related elements, so duplicates are intentional and necessary for functionality.

3)class locator:
The class attribute is used to apply CSS styles or JavaScript behaviors to multiple elements.
It allows developers to group elements that share similar styling or functionality.
Why Duplicates?:

The class attribute is meant to be reusable across multiple elements, so duplicates are expected and useful for consistent styling or behavior

Separation of Concerns:

The id attribute is reserved for unique identification, while name and class serve different purposes (grouping and styling).

4)linkText Locator
What it Does:
The linkText locator is used to find a hyperlink element by matching its exact visible text.

It is case-sensitive and requires the complete text of the link.

How it Works:
Selenium searches for an <a> tag whose inner text exactly matches the provided linkText.


5)partialLinkText Locator
What it Does:
The partialLinkText locator is used to find a hyperlink element by matching a portion of its visible text.

It is also case-sensitive but only requires a substring of the link text.

How it Works:
Selenium searches for an <a> tag whose inner text contains the provided partialLinkText.
----------------------------------------
Selenium Exceptions:


1)the By.className() locator only accepts a single class name. If you pass multiple class names (even if separated by spaces), it will throw an Selenium Exceptions
2)Avoiding numbers in IDs makes automation tests stable, maintainable, and reliable!
Many web applications generate IDs dynamically with numbers (e.g., button_123, input_456).
These IDs change on each page load, making tests unstable because selectors break when the number changes.
----------------------------------------
NoSuchElement : selenium exception


To locate a webElement in the DOM

1)inspect the Dom find the attribute
2)using webdriver findElement(), By.locator--> By.id("CaseSensitive")
 we should not type it manually , copy and paste it from the DOM
3)The attribule value should not be the duplicate value

button_123--> day1
button_6537--> day2


---------------------------------------

--------------------------------------------------------------------------------------
 
What is XPath?


XPath stands for XML Path Language. XPath is mainly used in XSLT(Extensible Stylesheet Language Transformations), A language used to transform XML documents into other formats (XML, HTML, text, etc.). because it enables precise and flexible navigation, querying, and filtering of XML data, which are fundamental operations for transforming XML documents effectively(Processes XML data and converts it into a different format or HTML format to display in a web browser.). but it is also popularly used for navigating through the DOM(Document Object Mode) of any XML-like language document using XPathExpression. 

Types of XPath
An XPath expression can be written in two ways 

A)Absolute
B)Relative


Definition and Structure:

 

Absolute XPath(Precise Data Selection): It starts from the root (html) and traverses down to the desired element, detailing every single element in the hierarchy. The path starts with a single forward slash /, indicating the root. 

For example: /html/body/div[2]/div[2]/div/form/p[1]/label.


Relative XPath: It starts from anywhere within the document and typically focuses on identifying elements based on attributes, indexes, or specific tags, not necessarily detailing the entire path from the root. It starts with a double forward slash //, indicating the search can begin anywhere. 

For example: //input[@id=‚Äòusername‚Äô].

1)Robustness:

Absolute XPath: It is less robust because if there are any changes in the path or structure of the web page, the XPath would break, leading to failed element location.

Relative XPath: It is more robust as it usually focuses on specific attributes or elements, making it less susceptible to changes in the overall structure of the webpage.

2)Length and Complexity:

Absolute XPath: These tend to be longer . They map the entire path from the root to the element, making them more complex.

Relative XPath: They are generally shorter and more concise, targeting specific elements directly without detailing the entire path, reducing complexity.


3)Flexibility and Use Cases:

Absolute XPath: It's less commonly used in dynamic web environments where page structures can change frequently.

Relative XPath: More commonly used in web automation and scraping because of its adaptability to web page changes and ability to precisely target elements.

4)Performance:

Absolute XPath: It can be slower in performance as it requires traversing the entire hierarchy of the DOM (Document Object Model) from the root.

Relative XPath: Generally offers better performance as it allows for more direct queries and doesn't necessarily traverse from the root.

--------------------------------------------------------------------------------------

Relative xpath

1)Node Navigation
  			Relative XPath provides a way to traverse XML trees, which is necessary for XSLT to locate nodes for transformation.
You can navigate:
Parent nodes (..)
Child nodes (/)
Descendant nodes (//)
Sibling nodes

2)Filtering and Conditions
 			Relative XPath allows the use of conditions to filter nodes based on attributes, text values, or structure

3)Data Manipulation
			Relative XPath provides functions for string manipulation, numeric calculations, and boolean operations. These are often needed during transformations to prepare data for output.

boolean()---->	This function accepts locator as parameter and it return true if the passed locator is found else returns false

count()------>	This function accepts locator as parameter and returns the count of elements found

position()--->	This function is used when we need to identify an element based on its position

id()--------->	This function accepts id attribute of the element and returns the element if found



--------------------------------------------------------------------------------------

###Basic xpath

1)Attribute based xpath

Syntax: //tagname[@attribute='attributeValue'] 
//input[@id='username']


üìå When to Use:

1)The HTML element has a unique or stable attribute.

2)Ideal for login fields, dropdowns, buttons, checkboxes when attributes are unique.

üí° Best choice when the attribute value is stable and unique.

Example://label[@for ='username']
	 	//label[@for='password']

*******************************************************
2)Text based xpath 

Syntax: //tagname[text()='text value'] 






//span[text()='Basic']

üìå When to Use:

1) When element text is static and visible to the user.

2) Works well for buttons, headers, tabs, links where text content is unique

üí° Easy to understand and highly readable, but avoid if text might change dynamically

Example://h2[text()='Leaftaps Login'] 
		//span[text()='Learn More'] 
		//a[text()='Commerce Setup Assistant']
********************************************************
3)Functions based xpath

Leverages functions  syntax like:
//tagname[contains(@attributeName,'attributeValue')]
//button[contains(@class,'mvm')]
A) Contains() :
contains(condition for the partial match)

returns elements with partial matches, 

üìå When to Use:

1) Attribute values are long or dynamic, and you only need to match part of it.

2) Used frequently in dynamic pages, like dashboards or search results.

Example: //div[contains(@class, ‚Äòheader‚Äô)].


B) Partial text based xpath:

syntax: //tagname[contains(text(),'partial text')] 
//button[contains(text(),'Up')]

üìå When to Use:

1) Text or attribute is partially predictable, like menu names or module links.

2) Often used when only part of a name is constant across builds.

Example: //a[contains(text(),'Lightning E')]



Partial Attribute based xpath

syntax: //tagname[starts-with(@attributeName,'partial attribute value')] 

Example: //button[starts-with(@class,'ui-state-disabled')]

*************************************************************************
4)Collection based xpath

Syntax: (any xpath)[index] Index will starts from 1 
(//button[contains(text(),'Up')])[2]

üìå When to Use:

1) When multiple similar elements are present and you want a specific one.

2) Common in table rows, repeated buttons, radio buttons, etc.

‚ö†Ô∏è Indexing should be used only when no better unique identifier is available, and the structure is stable.

Example: (//span[@class=' label bBody'])[3] 
	(//span[text()='Login'])[2]

--------------------------------------------------------------------------------------
XPath Type	     |	Ideal For
-------------------------------------------------------------------------------------
Attribute Based	 |	Most reliable for unique inputs, buttons, checkboxes
Text Based	 	 |	Tabs, buttons, headers, visible static elements
contains()	 	 |	Dynamic classes/IDs, partial attribute matching
Partial Text	 |	Menu items, labels with long/variable content
Collection with Index|	Tables, multiple buttons with same label
--------------------------------------------------------------------------------------